using System.Linq;
using System.Text;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GeneratedDI
{
    [Generator]
    public class DecoratorSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new InterfaceReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is InterfaceReceiver receiver))
                return;

            var compilation = context.Compilation;
            var namespaces = new HashSet<string>();
            var registrations = new StringBuilder();

            foreach (var ifaceDecl in receiver.CandidateInterfaces)
            {
                var model = compilation.GetSemanticModel(ifaceDecl.SyntaxTree);
                if (!(model.GetDeclaredSymbol(ifaceDecl) is INamedTypeSymbol ifaceSymbol))
                    continue;

                var attr = ifaceSymbol.GetAttributes().FirstOrDefault(a =>
                    a.AttributeClass?.Name == "DecorateAttribute" ||
                    a.AttributeClass?.ToDisplayString().EndsWith(".DecorateAttribute") == true);

                if (attr == null) continue;

                var ifaceNs = ifaceSymbol.ContainingNamespace?.ToDisplayString();
                if (!string.IsNullOrWhiteSpace(ifaceNs))
                    namespaces.Add(ifaceNs);

                var ifaceName = ifaceSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
                var baseName = ifaceName.StartsWith("I") ? ifaceName.Substring(1) : ifaceName;

                var implNs = ifaceNs;
                if (!string.IsNullOrWhiteSpace(implNs))
                    namespaces.Add(implNs);

                if (attr.ConstructorArguments.Length == 1)
                {
                    var value = (int)attr.ConstructorArguments[0].Value;
                    if ((value & 1) != 0) // 1 = Diagnostics is set
                    {
                        registrations.AppendLine($"            services.Decorate<{ifaceName}>((inner, s) => {{ var handler = s.GetRequiredService<IDiagnosticEntryHandler>(); return new {baseName}_DiagnosticDecorator(inner, handler);}});");
                        namespaces.Add(implNs);
                    }
                }
            }

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");

            foreach (var ns in namespaces.OrderBy(n => n))
                sb.AppendLine($"using {ns};");

            sb.AppendLine("using System;");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine();
            sb.AppendLine("namespace GeneratedDI");
            sb.AppendLine("{");
            sb.AppendLine("    public static class ServiceDecoratorRegistration");
            sb.AppendLine("    {");
            sb.AppendLine("        public static IServiceCollection RegisterDecorators(IServiceCollection services)");
            sb.AppendLine("        {");
            sb.Append(registrations);
            sb.AppendLine("            return services;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            context.AddSource("ServiceDecoratorRegistration.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }


        private class InterfaceReceiver : ISyntaxReceiver
        {
            public List<InterfaceDeclarationSyntax> CandidateInterfaces { get; } = new List<InterfaceDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is InterfaceDeclarationSyntax iface &&
                    iface.AttributeLists.Count > 0)
                {
                    CandidateInterfaces.Add(iface);
                }
            }
        }
    }
}
